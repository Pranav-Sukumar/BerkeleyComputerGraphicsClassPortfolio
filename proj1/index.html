<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Project 1: Rasterizer</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-opaquegray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="f0c71865-f615-46e3-a818-9593563fe69b" class="page sans"><header><img class="page-cover-image" src="https://www.notion.so/images/page-cover/rijksmuseum_avercamp_1620.jpg" style="object-position:center 60%"/><div class="page-header-icon page-header-icon-with-cover"><img class="icon" src="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_14-44-4%201.png"/></div><h1 class="page-title">Project 1: <strong>Rasterizer</strong></h1></header><div class="page-body"><h1 id="29b878aa-7b51-45e9-8f94-a8c077fac52c" class="">Ashwat Chidambaram, Pranav Sukumar - CS 284A (Spring 2023)</h1><h1 id="a6c31f7a-f8ae-445f-b186-ec899a2575d4" class="">üìú Project Overview</h1><p id="fbddb334-68ac-4137-9a3b-db71fdcc0c4d" class="">In this project, we built an overall system to rasterizer and render images onto a screen. Starting off with the most basic of tasks for rendering single-color triangles onto a screen, we built the foundations for displaying simple images through techniques such as the 3-line test and same-size </p><h2 id="5470b349-a78a-4ce5-a972-669cd945e2b1" class="">Task 1: <strong><strong>Drawing Single-Color Triangles</strong></strong></h2><p id="d28dd417-5f2f-4954-9362-f2ac6eeda57e" class=""><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Rasterizing Basic Triangles Algorithm and Approach:</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p id="8c4e9317-7abf-4743-a368-c9d30b5becac" class="">For Task 1, we implemented a rasterization algorithm for triangles which began by finding the smallest/tightest bounding box that could fully contain the triangle. The bounding box was calculated by finding the minimum and maximum x and y values over all three vertices. Once this bounding box was defined, we iterated over each point within the box (with the offset of 0.5 in the x and y directions to ensure the center of each pixel was considered) and performed a 3-line test using a helper function called <code>inside_triangle()</code> to verify if the specific coordinate was within the triangle. If the point was determined to be inside the triangle, we proceeded to rasterize it by calling the <code>rasterize_point()</code> function, which was responsible for assigning the corresponding color to the respective pixel in the sample buffer.</p><p id="43908fd8-a944-407b-ab59-61f746dea2e4" class=""><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Efficiency:</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><p id="6824f072-0df7-4ce3-8a44-028062793c35" class="">In terms of its efficiency, our approach was equivalent to one which checked each sample within the triangle&#x27;s bounding box, as that is exactly the method we followed. Therefore, the effectiveness of this approach is neither better nor worse than such an algorithm.</p><p id="6cb748b4-477a-43a9-8551-595e8ea2ca80" class="">
</p><figure id="74349f7d-8b65-47ce-b271-4200cb950c61" class="image"><a href="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_14-42-27.png"><img style="width:1600px" src="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_14-42-27.png"/></a><figcaption>Screenshot of our svg/basic/test4.svg output. Note the jaggies present in the image (made more obvious and clear by the zoomed-in pixel inspector).</figcaption></figure><h2 id="160443a1-dfa7-443a-b371-a69e9689bbdb" class=""><strong><strong>Task 2: Antialiasing by Supersampling</strong></strong></h2><p id="3ab3f008-cb5e-4289-bcd0-0223ebe92cfd" class="">For Task 2, we implemented our supersampling algorithm in order to improve the overall image quality, by reducing aliasing and mitigating ‚Äújaggies‚Äù from our previous work in Task 1. The basic premise of supersampling is that it samples individual pixels at a higher rate than individual pixels, and thereafter aggregates data from higher sampling frequencies to produce a smoother blended overall picture at the original resolution.</p><p id="97e23369-64c6-4bd3-afda-ffdf0cfeab4e" class="">The only data structure we needed to modify for this part was the <code>sample_buffer</code>. We increase the size by a factor of <code>sample_rate</code> in order to store the extra pixel information of our supersample. We do not modify the size of the frame buffer however, as that the final output should maintain the original size and resolution of our image as expected.</p><p id="c8ab36fb-bcf4-492f-a7a1-2327f4863dcb" class=""><strong>To accomplish our overall supersampling approach, we took the following steps and made the following modifications to the rasterization pipeline:</strong></p><ol type="1" id="1bbc9a08-a145-4ee2-bee6-999161eb4180" class="numbered-list" start="1"><li>Given that the entire supersample is technically a factor of <code>sample_rate</code> larger than the original size, this means the width and height need to scale up by a factor of <code>sqrt(sample_rate)</code>. As a result, we scale all the triangle coordinates in our <code>rasterize_triangle()</code> function by this factor.</li></ol><ol type="1" id="0f2d99d9-1d74-4514-8d7f-bcabd0c2ed84" class="numbered-list" start="2"><li>Thereafter, we iterate over these new larger-scale of pixels in the supersample (which is thus significantly more points than before at the original unscaled resolution). We proceed through the same process as Task 1 by searching over the triangle‚Äôs bounding box, performing the scaled 3-line test to determine which points fall in the triangle, and assigning colors accordingly to the <code>sample_buffer</code> at our higher resolution.</li></ol><ol type="1" id="63b65f0c-6059-4f08-b2d5-e73f21363c4c" class="numbered-list" start="3"><li>We also made slight modifications in the <code>rasterize_point()</code> and <code>fill_pixel()</code> functions, as singular points at the original resolution may now correspond to multiple points in the higher resolution supersampled <code>sample_buffer</code>. Since we don‚Äôt need to anti-alias points or lines (<code>rasterize_point()</code> is called by <code>rasterize_line()</code>), we modified these functions to fill in all nearby pixels in an area of <code>sample_rate</code> so they subsample properly in the final end result for the frame buffer. This ensures that all the information obtained from the supersampled pixels is properly taken into account when the final picture is rendered.</li></ol><ol type="1" id="edcb1bf3-ff68-43ea-b8e4-9417d57282a2" class="numbered-list" start="4"><li>Given that the larger supersampling resolution does not match the original frame buffer resolution, we finally made modifications in the <code>resolve_to_framebuffer()</code> function to ‚Äúdownsample‚Äù our supersample back to the original output image resolution. To achieve this, we iterate over all pixels in a region area of <code>sample_rate</code> from the <code>sample_buffer</code>, and within this supersampled region we simply average out all the color values, and finally assign the original single pixel coordinate to that color in the framebuffer. This technique of averaging out the color values is a very effective way to reduce aliasing and produce a much smoother picture.</li></ol><p id="377a3172-dc21-4431-bfde-55b20d9253b0" class="">Based on the results, we can see that supersampling is useful because it significantly mitigates jaggies and aliasing for the colors, thus improving the overall appearance of the images to the viewer. The reason it works well is because it considers pixels at a finer granularity (higher sampling rate), so we can better assess not just simply whether a pixel is part of a triangle, but also how much of that pixel is contained in the triangle. Visually, this allows us to go beyond the simplistic binary color choice of an empty vs. colored pixel, and rather further assign a color intensity (brighter or darker hues) based on our supersampled understanding of the image. This allows for smoother transitions and gradients on the edges of our triangles, instead of sudden color changes like previously implemented which is very sharp and edgy. As you zoom out and look at the image as a whole, it appears much more seamless to the human eye.</p><p id="e24e6d0d-d1d4-419d-88a9-ac03318ec757" class="">
</p><p id="6abd6234-2ddc-44ca-813c-667507823fe7" class="">
</p><figure id="b951a249-1306-4023-8658-c88aae52b0b9" class="image"><a href="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_15-44-1.png"><img style="width:1600px" src="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_15-44-1.png"/></a><figcaption>Screenshot of our svg/basic/test4.svg output with supersample rate of 1 sample per pixel. Note the jaggies present in the image (made more obvious and clear by the zoomed-in pixel inspector).</figcaption></figure><figure id="6cc89050-beb5-4838-877c-5ee0a7aa75ac" class="image"><a href="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_15-44-7.png"><img style="width:1600px" src="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_15-44-7.png"/></a><figcaption>Screenshot of our svg/basic/test4.svg output with supersample rate of 4 samples per pixel. Note the slight anti-aliasing resulting from the supersampling.</figcaption></figure><figure id="730b5f57-335b-49b1-82ed-d9e9dfaa95bc" class="image"><a href="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_15-44-10.png"><img style="width:1600px" src="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_15-44-10.png"/></a><figcaption>Screenshot of our svg/basic/test4.svg output with supersample rate of 16 samples per pixel. Note the large amount of anti-aliasing resulting from the supersampling.</figcaption></figure><h2 id="2b141f02-c11d-4a44-8a6b-359c9e67669b" class=""><strong><strong>Task 3: Transforms</strong></strong></h2><p id="e864eb51-6de1-491f-bec6-198b178372e5" class="">For Task 3, we implemented various pixel transformations, in particular for supporting translation, scaling, and rotations. To showcase our successful efforts, we decided to change up the picture.</p><p id="a0db843a-c80d-4195-a34b-b058bba22782" class="">Don‚Äôt get me wrong, cubeman is a cool dude, but you know what‚Äôs cooler than cubeman? That‚Äôs right, Iron Man. We upgraded cubeman to include his very own hand-crafted arc reactor in his chest, taught him how to fly in the latest Mark LXXXVI suit by angling his hands downward with flames shooting out of his hands and legs, and finally gave him the signature red and gold helmet and suit colors to complete the fit. There is undoubtedly no better, more powerful, intelligent, charismatic, philanthropic, and rizzed-out cubeman in the entire history of CS 284A than our very own Iron Man edition. Avengers assemble!</p><figure id="e5e2c44a-fda0-4d81-aa6d-2867e1d54284" class="image"><a href="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_14-44-4.png"><img style="width:1600px" src="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_14-44-4.png"/></a><figcaption>Above is a screenshot of our Iron Man.</figcaption></figure><h2 id="f79e9a74-8bdb-4e66-841f-0e84f588899d" class=""><strong><strong>Task 4: Barycentric Coordinates</strong></strong></h2><p id="64fa08d5-a4bb-417a-9e5f-23d100727b4b" class="">Barycentric coordinates are a method of representing points within triangles, utilizing weights assigned to the three vertices in order to interpolate values inside the triangle. The three weights (alpha, beta, and gamma) are calculated using proportional distances to the vertices and the line equation. These three weights are multiplied by corresponding values at the vertices (these can be colors, positions, or texture coordinates), added up, and ultimately result in an accurate point location within the triangle. This technology can be utilized to create attractive color mixes and gradients within various polygons. </p><p id="8dc1ede5-69fb-40ce-9972-1d5a7932c619" class="">For example, the figure below displays an isosceles triangle that we have generated, with weighted points between the red, green, and blue colors that were assigned to each point in the triangle. As we traverse the figure, the colors at any single point will steadily shift in accordance with the r/g/b vertices that are closest to it. This produces a gradient effect, as the colors blend together in a gentle, progressive transition. Moreover, by adjusting the weight of each vertex, we can precisely control the color combination at any point, allowing us to create even more graphical effects.</p><figure id="a4d03c1c-7169-47cb-aec0-98d2124424ac" class="image"><a href="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_14-59-7.png"><img style="width:1600px" src="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_14-59-7.png"/></a><figcaption>Above is a screenshot of a custom-rendered barycentric interpolated triangle.</figcaption></figure><p id="32c6ad7c-10ce-4762-acb2-cc1de32e46c1" class="">
</p><figure id="d0c1b94b-22fb-494a-ac0b-09923993ad87" class="image"><a href="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_15-1-46.png"><img style="width:1600px" src="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_15-1-46.png"/></a><figcaption>Above is a screenshot of our svg/basic/test7.svg color wheel output.</figcaption></figure><p id="3137b75b-f810-407c-9d7e-2c971b4c8141" class=""><strong>Barycentric Coordinates Algorithm and Approach:</strong></p><ol type="1" id="39c23c2b-29f9-4d15-897d-0c3e0fc68f0e" class="numbered-list" start="1"><li>In <code>rasterize_interpolated_color_triangle()</code> after checking if a sample was inside the triangle, we calculated alpha, beta, and gamma values using the formulas from the lecture slides:</li></ol><p id="04da8fc9-8f46-403e-822e-ced5df65d8e0" class=""><code><strong>float</strong></code><code> alpha = ((-(x-x1)*(y2-y1))+((y-y1)*(x2-x1))) / ((-(x0-x1)*(y2-y1))+((y0-y1)*(x2-x1)));</code><code><strong>float</strong></code><code> beta = ((-(x-x2)*(y0-y2))+((y-y2)*(x0-x2))) / ((-(x1-x2)*(y0-y2))+((y1-y2)*(x0-x2))); </code><code><strong>float</strong></code><code> gamma = 1-alpha-beta;</code></p><ol type="1" id="c3f8ce86-0992-463e-82ef-3b28251c5044" class="numbered-list" start="2"><li>Once we calculated the alpha, beta, and gamma values, we calculated the appropriate color by multiplying each weight with the corresponding vertex value:</li></ol><p id="fa80be0b-deef-4a32-85de-68c15066f1b2" class=""><code>(alpha*</code><code><em>c0) + (beta*</em></code><code>c1) + (gamma*c2)</code></p><h2 id="6ff7071d-ca12-460a-a43a-66b2308cd2b0" class=""><strong><strong>Task 5: &quot;Pixel sampling&quot; for Texture Mapping</strong></strong></h2><ul id="b7c665b0-0917-405e-b308-85de2c784432" class="bulleted-list"><li style="list-style-type:disc">Explain pixel sampling in your own words and describe how you implemented it to perform texture mapping. Briefly discuss the two different pixel sampling methods, nearest and bilinear.</li></ul><ul id="1932583d-987b-4369-a90c-13edf1d4a43e" class="bulleted-list"><li style="list-style-type:disc">Check out the¬†<em>svg</em>¬†files in the¬†<em>svg/texmap/</em>¬†directory. Use the pixel inspector to find a good example of where bilinear sampling clearly defeats nearest sampling. Show and compare four¬†<em>png</em>¬†screenshots using nearest sampling at 1 sample per pixel, nearest sampling at 16 samples per pixel, bilinear sampling at 1 sample per pixel, and bilinear sampling at 16 samples per pixel.</li></ul><ul id="895160c9-9244-4214-82bd-66f5aa76a5bf" class="bulleted-list"><li style="list-style-type:disc">Comment on the relative differences. Discuss when there will be a large difference between the two methods and why.</li></ul><p id="fa496c5d-1217-4fcd-86a3-60ff46c854f1" class="">
</p><p id="288d642e-1693-4570-8661-79fd54f5844e" class=""><strong>Pixel Sampling Overview:</strong></p><p id="b4f27be7-89cb-4465-a4dc-0eb21933fc65" class="">Pixel sampling is really cool.</p><p id="833ac269-b6d7-4201-9871-dbeb129b4d9d" class="">The two main pixel sampling methods are <em>nearest</em> sampling and <em>bilinear </em>sampling:</p><ul id="6a8d92c6-19ed-48e3-80c2-ab1f1da41f2c" class="bulleted-list"><li style="list-style-type:disc"><strong>Nearest Neighbor Sampling</strong>: This is a simple method of determining the color of a pixel by simply sampling the nearest pixel coordinate by rounding the x/y coordinates, and then assigning that color to the original target pixel on the image. This method is simple and quick to compute but unfortunately does not produce the best visual output as it simply adopts a color from one of its neighbors, instead of considering them all. If no supersampling is used, nearest neighbor sampling can lead to aliasing and jaggies.</li></ul><ul id="11d5b212-9f78-483d-8b27-3357201c3fc5" class="bulleted-list"><li style="list-style-type:disc"><strong>Bilinear Pixel Interpolation Sampling:</strong> This is a slightly more complex method of determining the color of a pixel by considering all four nearest neighbor pixels, and uses <em><em><em><em><em><em><em><em>linear interpolation</em></em></em></em></em></em></em></em> (‚Äùlerp‚Äù) to provide weights to these four neighbors‚Äô colors and ultimately determine the final color for the original target pixel on the image. This method is more involved and clever as it takes into account all four neighbors and computes a color that blends surrounding colors together.</li></ul><p id="81139254-74fc-4b10-a92e-705546859c4a" class=""><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>Pixel Sampling Algorithm and Approach:</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p><ol type="1" id="19eb9814-d9ce-42f2-86ae-c1286c0d8363" class="numbered-list" start="1"><li>We first had to implement the <code>rasterize_textured_triangle()</code> function in rasterizer.cpp. We implemented</li></ol><p id="04805dce-6508-4b32-a112-7d845e2c21ae" class="">
</p><div id="9dd6afa0-f038-42c0-a927-deed8d89889b" class="column-list"><div id="417851c2-fe62-40f1-9832-d92835e667e2" style="width:50%" class="column"><figure id="ca828e21-22b3-4692-9ed3-2adeadd9e3db" class="image"><a href="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_16-1-50.png"><img style="width:1600px" src="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_16-1-50.png"/></a><figcaption>Above is a screenshot of our svg/texmap/test5.svg output with <strong>nearest neighbor sampling</strong> with a <strong>supersample rate of 1</strong> samples per pixel.</figcaption></figure></div><div id="579e591b-5b37-42bd-a81c-dbc7c1435f61" style="width:50%" class="column"><figure id="469baeba-6a7b-403f-8973-d104e3d958da" class="image"><a href="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_16-1-54.png"><img style="width:1600px" src="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_16-1-54.png"/></a><figcaption>Above is a screenshot of our svg/texmap/test5.svg output with <strong>bilinear pixel interpolation</strong> sampling with a <strong>supersample rate of 1</strong> samples per pixel.</figcaption></figure></div></div><div id="314eca80-8704-44d7-82b2-c243dacadd51" class="column-list"><div id="ef27a0db-7f50-4abc-8334-82072dbfa559" style="width:50%" class="column"><figure id="67228705-f87a-4c8b-884d-0bb0bbf1ce48" class="image"><a href="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_16-2-1.png"><img style="width:1600px" src="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_16-2-1.png"/></a><figcaption>Above is a screenshot of our svg/texmap/test5.svg output with <strong>nearest neighbor sampling</strong> with a <strong>supersample rate of 16</strong> samples per pixel.</figcaption></figure></div><div id="eb47c7ae-edd5-4d7c-ad6d-be73c12c2af1" style="width:50%" class="column"><figure id="e5953c45-fe95-4169-b479-78d38f6397eb" class="image"><a href="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_16-2-4.png"><img style="width:1600px" src="Project%201%20Rasterizer%20f0c71865f61546e3a8189593563fe69b/screenshot_2-14_16-2-4.png"/></a><figcaption>Above is a screenshot of our svg/texmap/test5.svg output with <strong>bilinear pixel interpolation</strong> sampling with a <strong>supersample rate of 16</strong> samples per pixel.</figcaption></figure></div></div><p id="72d5274f-5abc-45ef-a936-2870e93c067f" class="">There are various differences when comparing the results above. First and foremost, it is very clear that bilinear pixel interpolation has a clear advantage over nearest neighbor sampling, as the images look much more smooth and blended. This stark difference is especially apparent at a low supersampling rate (such as 1), which can easily be observed looking at the zoomed-in pixel inspector previews on the top-right of each image. However, the difference between nearest sampling vs. bilinear sampling becomes much less apparent as the sampling rate increases (up to 16). This is because‚Ä¶ <strong><strong><strong><strong><strong><strong><strong>xyz abc</strong></strong></strong></strong></strong></strong></strong>. Nonetheless, </p><h2 id="e3c43c89-3f19-4e28-b129-eab0a5e961ee" class="">T<strong><strong>ask 6: &quot;Level Sampling&quot; with Mipmaps for Texture Mapping</strong></strong></h2><p id="38812b99-1492-4fa6-8cc0-9379003d3cb1" class="">
</p><p id="87bf78b8-cc56-45ec-a8fb-8e1f5dd0ac2e" class="">
</p><h1 id="4d294639-503e-402e-85cb-82ed500c7d67" class="">üé¨¬†Conclusion</h1><p id="a62bab07-812b-46b6-8778-b46ecbdd0d9b" class="">Overall, this was a really intriguing and fun project to work on! We truly learned a lot about coding in C++, trying out various methods and approaches for optimal graphics rendering, and the immense satisfaction when visualizing smooth anti-aliased images without jaggies and seeing their awesome results!</p></div></article></body></html>